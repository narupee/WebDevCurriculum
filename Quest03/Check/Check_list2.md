
### "튜링머신" 이란?

- 튜링머신 (Turing machine)
- 수학 또는 이론 전산학에서 긴 테이프에 쓰여 있는 여러 가지 기호들을 일정한 규칙에 따라 바꾸는 기계
- 적당한 규칙과 기호를 입력하면 일밪ㄴ적인 컴퓨터의 알고리즘을 수행하며, CPU의 기능을 설명하는데 상당히 유용함
- 1936년 앨런 튜링은 계산하는 기계를 대표할 수 있는 가상의 장치를 만듬
- 이 장치에 영어 단어인 automatic의 a를 따서 "a-기계"라는 이름을 붙임
- '창시자인 앨런 튜링'의 이름을 따서 '튜링 기계'라 불리게 되었다.
- 1936년 논문 "계산 가능한 수와 결정성 문제에의 응용"을 언급하며, <br>
   튜링기계(이 글에서는 논리적 계산 기계라는 표현을 사용한다.)
- 튜링 기계가 가진 기호와 상태, 행동은 모두 유한하고 이산적이며, 구분 가능 하다.

---

Q1. <big>XML, YAML, Markdown의 문법 차이와 주 용도를 이해하기</big>
   <br>
- XML : 데이터를 표현하기 위해 많이 사용되어 온 방식 -> 태그 표현 (HTML 과 흡사한 구조를 가짐)
  - `HTML` 처럼 데이터를 보여주는 목적이 아니다.
  - 데이터를 저장하고 전달할 목적으로 만들어진 `XML`
  - '트리계층 구조'를 가졌으며, 루트 요소부터 시작해 여러 개의 '자식을 계층적' 으로 포함 한다.
  - `XML 문법`
    - 규칙적인 형태, 태그와 태그 사이에 요소를 적어 넣는 방식 구성
    - 시작 태그와 종료 태그는 대소문자까지 모두 동일해야 한다.
    - 태그 안에 속성을 명시할 때는 따옴표를 넣어줘야 한다.
    - <!--주석 내용--> 형태로 사용
    - 문법적인 오류가 발생해도 각각 태그로 구분되어 있기 때문에 다른 태그들은 컴퓨터가 읽을 수 있다.
    - 안정성을 요구하는 곳에서 사용하면 좋다.

  
      <Title color ='black' type= 'bold'>글자</Title>
 
<br>

- YAML : 사람이 읽기 쉬운 형태의 " 데이터 표현 형식 " 이다.
  - `XML`과 문법적으로 유사하다.
  - 주석이 가능, 개행(줄바꿈 문자), 공백으로 블록을 인식한다.
  - 쓰고 있는 사람의 편의를 우선시 한다.
  - `docker compose`, `spring`의 설정 파일에 자주 사용하게 된다.
    - `docker compose`란? 
    - 다중 컨테이너 애플리케이션을 정의 공유할 수 있도록 개발된 도구로
    - 단일 명령을 사용하여 모두 실행 또는 종료할 수 있도록 개발된 도구
    - 다중 컨테이너 애플리케이션을 정의 공유할 수 있도록 개발된 도구로
    - 하나의 문서에 여러 개의 컨테이너를 정의할 수 있다
    - `docker compose` <사용 예시>
  

         services:
         nhn_app:
         image: nhn_app_v2

         nhn_mysq:
         image: mysql
   - `YAML` 문법
   - 개행, 공백으로 불록 인식함
   - 다만, 태그를 사용하지 않고 공백 위주로 '데이터를 구분'하므로 한 줄로 작성할 수 없음
   
   <br>

   - `YAML` 용도
   - reference가 있는 YAML은 복잡한 object 구조를 표현하는데 적합
   - 오프라인에서 data serialization을 위해 더 적합
     - `serialization (시리얼라이제이션)`이란?
     - `== 직렬화 (Serialize)` 한글로 번역하면 이렇다!
       - 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술
       - `JVM (Java Virtual Machine 이하 JVM`의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 byte 형태로 변환하는 기술
       - 직렬화 조건 : `java.io.Serializable` 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건
       - 직렬화 방법 : `java.io.ObjectOutputStream` 를 사용하여 직렬화를 진행
       <br>
       <br>
     - `역직렬화 (Deserialize)`
       - byte로 변환된 Data를 원래대로 Object로 변환하는 기술
       - 직렬화된 바이트 형태의 데이터를 "객체로 변환해서 JVM으로 상주시키는 형태"
       - 역직렬화 조건 
         - 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 합니다.
         - 중요한 점은 직렬화와 역직렬화를 진행하는 시스템이 서로 다를 수 있다는 것을 반드시 고려해야 합니다.
         - 자바 직렬화 대상 객체는 동일한 serialVersionUID 를 가지고 있어야 합니다.
           - `private static final long serialVersionUID = 1L;`
       - 역직렬화 방법 : `java.io.ObjectInputStream`를 사용하여 역직렬화를 진행
       <br>
       <br>
     - [ 총 정리 ]
       - 외부 저장소로 저장되는 데이터는 짧은 만료시간의 데이터를 제외하고 자바 직렬화를 사용을 지양함
       - 역직렬화시 반드시 예외가 생긴다는 것을 생각하고 개발하기
       - 자주 변경되는 비즈니스적인 데이터를 자바 직렬화를 사용하지 않음
       - 긴 만료시간을 가지는 데이터는 JSON 등 다른 포맷을 사용해 저장함
       - 추가) 직렬화 방법은 `OutputStream`, 역직렬화 방법은 `InputStream` 사용!
       <br>
       <br>
- `Markdown` 주 용도
  - 태그로 이루어진 HTML 문서 등과 달리, 읽기도 쓰기도 쉬운 문서 양식을 지향한다.
  - 다른 마크업 언어(XML,YAML 등등)에 비해 기능이 적은 대신 가볍고 문법이 쉽다.
  - 확장자는 `.md` 또는 `.markdown`을 쓰지만, 전자가 압도적으로 많이 쓰인다.

<br>

- XML은 요즘 환경에서 사람이 작성할 일은 거의 없습니다. 
- 하지만 여전히 RSS등 레거시 호환을 위해서 많이 사용하고 있습니다.
- YAML, Markdown은 사람이 작성할 일이 많기 때문에 직접 작성이 가능하면 좋을 것 같습니다. 

<br>

- `RSS (Really Simple Syndication)`이란?
  - RSS는 리얼(Real) 심플(Simple) 신디케이션(Syndication)이라는 뜻
  - Real = 정말로, 진짜로
  - Simple = 심플한, 간단한
  - Syndication = 조직, 연합, 신디케이션
  - "사이트 피드"란, 새 기사들의 제목만, 또는 새 기사들 전체를 뽑아서 <br>
     하나의 파일로 만들어 놓은 것
  - 모든 사이트에서 RSS피드를 제공하지 않는다.
  - 1년 내내 새로운 내용이 없는 정적인 사이트는 제공하지 않는게 보통이며, <br>
    새로운 읽을 거리가 자주 올라오는 "뉴스형", "블로그형" 사이트에 주로 제공된다.
  - RSS피드 주소를 얻었으면 "RSS 리더기"에 주소를 넣어서 구독(Subscribe)해야 한다.
  - 사람이 RSS를 직접 읽는 것이 아닌 "RSS리더기가 자동으로 알려주고 보여주는 것"
  - RSS 주소를 가지고 있으면 도움이 되는 장점은?
    - A,B,C의 각종 SNS플랫폼을 연결시키면 동시 다발적으로 RSS 고유 주소로 연동시킨 블로그와 SNS에서는 <br>
      동일하게 A블로그에서 포스팅한 자료를 자동으로 받아 볼 수 있다.
<br>
<br>
- `레거시 (Legacy) 호환`이란?
  - 유산 이라는 뜻의 영단어
  - 현재까지 남아 사용되고 있거나 현재의 체계에 영향을 미치는 과거의 체계를 뜻함
  - 광범위하게 쓸 수 있으나 단, 정치에 쓰는 말은 아니다. 
  - 구체제란 용어는 `Ancien regime`이란 말이 따로 있다.
- `Legacy System`
  - 컴퓨터 용어로는 하위 호환을 위해 신규 프로그램 속에 남겨두는 <br>
    기존 프로그램의 소스 코드를 뜻한다.
- `필요성`
  - 효율적인 소스 코드가 개발 되었다고 할때, 해당 프로그램의 다음 업데이트 버전에서는 <br>
    프로그램 효율성 증가를 위해 새로 개발된 소스 코드를 사용함
  - 이를 위해 기존의 소스 코드를 모두 삭제하거나 수정해 버리면, <br>
    기존 프로그램을 이용해왔던 사람들이 순식간에 해당 프로그램을 사용하지 못하게 되는 사태가 일어난다.
  - 온라인 게임이나 온라인 연동 모바일 앱에서는 강제 업데이트를 통해 해결하지만, <br>
    온라인 연동 없이 오프라인 환경에서 사용되는 프로그램처럼 업데이트를 강제할 수 없는 상황에서는 <br>
    업데이트를 하지 않은 버전으로도 작동이 되도록 " 하위 호환을 제공해줄 필요 "가 있다.
- `해결책`
  - 호환성을 위한 레거시 지원은 단기적으로는 필요하나, <br>
    장기적으로는 기존 시스템을 폐지하는 개혁이 필요함
  - 레거시 폐지는 혼란을 가져올 우려가 있으므로, 충분한 기간을 두고 레거시 폐지를 예고한 후 <br>
    이 기간 동안 사용자 층의 사전 준비와 공감대를 이끌어내는 것이 중요함

---

Q2. <big> CSS </big>
- CSS의 어려움(단점들)을 극복하기 위한 방법
  - 전처리기를 위한 도구가 필요, 다시 컴파일하는 시간이 느릴 수 있음
  - Less에서는 변수 이름의 접두어가 @이며, @media, @import, @font-face 규칙과 같은 <br>
    고유 CSS 키워드와 혼동될 여지가 있음
  - Sass에서는 노드 버전을 바꿀 때 자주 다시 컴파일해야 함
  
- 각각의 핵심 철학이나 기능이 무엇인가
  - `Sass`
    - 가장 오래되었고, 가장 활발히 개발되고 있으며, 가장 많은 사람들이 선택한 라이브러리라 이용할거리가 많다
    - 막강한 내장 기능들을 갖고 있으며, Compass와 병용하면 리소스 경로를 직접 참조 가능해서, <br>
      특정 폴더 내 이미지를 모두 참조한다든가, 이미지 크기를 참조할 수도 있다
    - 디펜던시로서 ruby를 요구합니다. (Libsass라는 대체재 덕분에 완화되고 있지만 아직 완전하지는 않습니다.)
  - `Less`
    - 브라우저에 내장된 JS 인터프리터만으로 컴파일 가능하므로 그만큼 디펜던시에서 자유롭다
    - Sass 다음으로 활발히 개척되고 있어서, 쓸만한 라이브러리나 mixin 구현물들을 제법 쉽게 찾을 수 있다
  - `Stylus`
    - 상대적으로 프로그래밍 언어의 특징을 많이 포함하고 있다
    - 위 특징 때문에, CSS 프로퍼티 내에서 연산자나 함수, 루프 등을 비교적 자유롭게 사용할 수 있다
    - 반대로 위 특징 때문에, 문법이 혼재해 있어서 처음 전처리를 시작하는 사람에게는 상대적으로 장벽이 높다
  - `CSS 전처리기도 컴파일러와 같은 역할을 하는데 그 목적 코드가 CSS 이다!`
  <br>
  <br>
- CSS가 브라우저에 의해서 해석되는 과정을 이해하는 것
  - 프로그래밍 언어는 운영체제(Operating System, OS) 위에서 실행되지만 <br>
    웹 애플리케이션의 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. <br>
    브라우저 환경을 고려하며 브라우저가 어떻게 동작하는지 이해하는 것은 효율적인 자바스크립트 프로그래밍의 밑거름이 될 것이다
  - `브라우저의 핵심 기능`: 사용자가 참조하고자 하는 웹페이지를 <br>
     서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것
  - 브라우저는 서버로부터 HTML, CSS Javascript, 이미지 파일 등을 응답 받는다.
  - HTML, CSS 파일은 `렌더링 엔진`의 HTML 파서와 CSS 파서에 의해 해석 과정(Parsing)을 거치면서 <br>
    `DOM, CSSOM 트리로 변환되고 렌더 트리에 결합`된다.
  - 이렇게 생성된 렌더 트리를 기반으로 브라우저는 사용자에게 웹 페이지를 출력한다.
  - 이때 자바스크립트는 렌더링 엔진이 아니라 `자바스크립트 엔진`이 처리하는데, <br>
    HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 <br>
    DOM 생성을 멈추고 script 태그 내부의 자바스크립트 코드 또는 src 속성에 정의되어 있는 자바스크립트 파일을 로드하고 실행한다.
- 이부분은 링크를 통해 한번 더 읽어 보면 좋을 듯 하다 [[링크]](https://hyuns.netlify.app/browsers-work/)
---

Q3. <big> V8엔진 </big>
- 기존 Advanced + Chromium의 V8엔진의 구조
- 코드 실행 로직 V8엔진의 철학 학습!
- 현재의 JS 생턔계가 갖춰지는데 있어서 V8엔진은 핵심이다.
<br>
<br>
- `V8엔진` 이란?
- `V8엔진` 공식 홈페이지 설명
  - V8은 C++로 작성된 Google의 오픈 소스 고성능 JavaScript 및 WebAssembly 엔진이다.
  - Chrome 및 Node.js 등에서 사용된다.
  - ECMAScript 및 WebAssembly를 구현 하고 x64, IA-32, ARM 또는 MIPS 프로세서를 사용하는 <br>
    Windows 7 이상, macOS 10.12+ 및 Linux 시스템에서 실행된다.
  - V8은 독립 실행형으로 실행되거나 모든 C++ 애플리케이션에 포함될 수 있다.
<br>
<br>
  - 추가로 찾아본 `V8엔진 이란?`
    - 웹 브라우저를 만드는 데 기반을 제공하는 오픈 소스 자바스크립트 엔진이다.
    - ECMAScript(ECMA - 262) 3rd Edition 규격의 C++로 작성
    - 독립적으로 실행이 가능
    - C++로 작성된 응용 프로그램의 일부로 작동할 수 있다.
    - 자바스크립트를 `바이트코드(bytecode)로 컴파일하고 실행하는 방식을 사용`한다.
    - 속도향상을 위해 인라인 캐싱(inline caching)과 같은 최적화 기법을 적용
- 개인적인 생각을 겨뜨리 면 `V8엔진`은 `"최적화 속도, 최적화 관리"`가 중요한 부분! 이라고 생각이 든다.
<br>
<br>
- `V8엔진`의 구조
  - C++로 만들어진 자바스크립트 & 웹 어셈블리 엔진
  - 크롬과 nodeJS에서 사용되는중
  - ESMAScript와 WebAssembly를 표준에 맞게 구현

- V8엔진 참고하기 출처 [(링크)](https://www.stevy.dev/2ddf9045-8f74-4054-b5c3-2e3a64cfe3b0)




---

